# 아이템 1. 생성자 대신 정적 팩토리 메소드를 고려하라.

-----

## 1. 목표
- 자바의 클래스는 인스턴스를 얻는 수단으로 생성자 or 정적 팩터리 메서드가 있다.
- 정적 팩터리 메서드의 장점과 단점을 확인하고 언제 사용할지 판단하도록 하자.  

## 1. 정적 팩터리 메서드란?
#### 인스턴스 객체를 만들어주는 역할을 하는 메서드

## 2. 정적 팩터리 메서드의 장점
<br></br>

### 1. 이름을 가질 수 있다.
- 동일한 시그니처의 생성자가 두개인 경우에 정적 팩터리 메서드를 이용하면 객체를 생성할 때 특징을 잘 표현해 줄 수 있다.  

```
// 예시 코드
public class Order{
    private boolean prime;
    private boolean urgent;
    private Product product;
    
    public static Order primeOrder(Product product){
        Order order = new Order();
        order.prime = true;
        order.product = product;
        return order;
    }
    
    public static Order urgentOrder(Product product){
        Order order = new Order();
        order.urgent = true;
        order.product = product;
        return order;
    }
}
```

<br></br>
### 2. 호출될 때마다 인스턴스를 새로 생성하지 않아도 된다.
- 매개변수에 따라 각기 다른 인스턴스를 제공할 수 있다.
- Flyweight Pattern : 자주 사용하는 값들을 미리 생성 해놓고 꺼내다가 쓰는 패턴

```
// 예시 코드
public class Settings {

  private boolean useAutoSteering;

  private boolean useABS;

  private Difficulty difficulty;

  private Settings() {
  }

  private static final Settings SETTINGS = new Settings();

  // 인스턴스를 통제
  public static Settings newInstance() {
    return SETTINGS;
  }
}
```

<br></br>
### 3. 반환 타입의 하위 타입 객체를 반환할 수 있다.
- 인터페이스 기반 프레임워크, 인터페이스에 정적 메소드
###

### 4. 입력 매개변수가 따라 매번 다른 클래스의 객체를 반환할 수 있다.
- 반환하는 구현체를 숨길 수 있다. (EnumSet)
###

### 5. 정적 팩터리 메서드를 작성하는 시점에는 반환할 객체의 구현체는 존재하지 않아도 된다.
- 구현체를 의존하지 않고 인터페이스 기반으로 유연한 개발을 할 수 있다. 
- Service provider framework 를 만드는 근간 (서비스 제공자 프레임워크)

```
public interface HelloService {
    
    String hello();
    
    // static 한 메서드를 인터페이스에 선언할 수 있음
    static HelloService of(String lang) {
      if (lang.equals("ko")) {
        return new KoreanHelloService();
      } else {
        return new EnglishHelloService();
      }
    }
}
```

```
public static void main(String[] args) {
    // 참조된 다른 모듈에서 구현체를 가져올 수도 있다.
    
    // 구현체에 의존하지 않음
    ServiceLoader<HelloService> loader = ServiceLoader.load(HelloService.class);
    Optional<HelloService> helloServiceOptional = loader.findFirst();
    helloServiceOptional.ifPresent(h -> {
      System.out.println(h.hello());
    });

    // 구현체에 의존함
    KoreanHelloService koreanHelloService = new KoreanHelloService();
    System.out.println("koreanHelloService.hello = " + koreanHelloService.hello());
 }
```
