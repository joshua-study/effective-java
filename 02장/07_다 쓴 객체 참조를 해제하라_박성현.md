# 7. 다 쓴 객체 참조를 해제하라.

---

### Memory Leak (메모리 누수)
- 프로그램을 오래 실행하다 보면 GC 활동과 메모리 사용량이 늘어나 성능 저하가 발생할 수 있다.
- 심할 때는 디스크 페이징이나 OutOfMemoryError를 일으켜 프로그램이 종료될 수 있다.

#### 어떤 객체에 대한 레퍼런스가 남아있다면 해당 객체는 GC의 대상이 되지 않는다.
- 객체 참조 하나를 살려두면 GC는 그 객체뿐 아니라 그 객체가 참조하는 모든 객체를 회수하지 못한다.
- 해당 참조를 다 사용했을 때 null 처리(참조 해제)하면 해결 가능하다.
```java
public class Stack {
    // ...

    public Object pop() {
        if (size == 0)
            throw new EmptyStackException;
        Object result = elements[--size];
        element[size] = null; // 다 쓴 참조 해제
        return result;
    }
}
```
- 만약 null 처리한 참조를 실수로 사용하려 하면 NPE를 던지며 종료된다.
<blockquote>
하지만 객체 참조를 null 처리하는 일은 예외적인 경우여야 한다.

다 쓴 참조를 해제하는 가장 좋은 방법은 그 참조를 담은 변수를 유효 범위(scope) 밖으로 밀어내는 것이다.
</blockquote>

---

### null을 사용하여 참조 해제하는 경우
자기 메모리를 직접 관리하는 클래스, 위의 예제인 Stack 클래스는 element 배열로 저장소 풀을 만들어 원소들을 관리한다.
- 배열의 활성 영역에 속한 원소들이 사용되고, 비활성 영역은 쓰이지 않는다.
- 여기서 비활성 영역의 객체가 쓰이지 않는다는 것은 프로그래머만 아는 사실일 뿐, GC는 알지 못한다.
- GC가 보기에는 비활성 영역에서 참조하는 객체도 똑같이 유효한 객체이다.
<blockquote>
프로그래머는 비활성 영역이 되는 순간 null 처리해서 해당 객체는 더이상 쓰지 않을 것임을 GC에 알려야한다.

자기 메모리를 직접 관리하는 클래스라면 프로그래머는 항시 메모리 누수에 주의하자.
</blockquote>

### 메모리 누수에 취약한 클래스
자기 메모리를 직접 관리하는 클래스.
- 스택, 캐시, 리스너, 콜백

#### 캐시
- 객체 참조를 캐시에 넣고, 그 객체를 다 쓴 뒤로도 한참을 놔둔다면 메모리 누수 문제가 발생할 수 있다.
- 캐시를 만들 때 보통은 캐시 엔트리의 유효 기간을 정의하기 어렵다.
- 때문에, 시간이 지날수록 엔트리의 가치를 떨어뜨리는 방식을 사용한다.
- 백그라운드 스레드를 활용하거나 캐시에 새 엔트리를 추가할 때 부수 작업으로 수행하는 방법이 있다.

#### 리스너 혹은 콜백
- 클라이언트가 콜백을 등록하고 명확히 해지하지 않는다면, 조치를 취하지 않는 한 콜백은 계속 쌓일 것이다.
- 콜백을 약한 참조로 저장하면 GC가 즉시 수거해간다.

---

## 핵심 정리
```
메모리 누수는 겉으로 잘 드러나지 않아 시스템에 잠복하는 사례도 있다.
이런 누수는 철저한 코드 리뷰나 힙 프로파일러 같은 디버깅 도구를 동원해야만 발견되기도 한다.
메모리 누수가 일어나지 않도록 예방법을 익혀두는 것이 매우 중요하다.
```